diff --git a/.zlogin b/.zlogin
index 610fbb8..e4c2353 100644
--- a/.zlogin
+++ b/.zlogin
@@ -1,6 +1,37 @@
 # shellcheck shell=zsh
 if [[ -o interactive ]]; then
-    print -n -P "[%F{yellow}.zlogin%f]"
+    curr=$(($(date +%s) * 1000 + $(date +%N | cut -b1-3)))
+    diff="$((curr - IMGNXZINIT))"
+    if [[ diff -gt 1000 ]]; then
+        diff="%F{yellow}$(printf "%d.%03d" "$((diff / 1000))" "$((diff % 1000))")%f"
+    elif [[ diff -gt 300 ]]; then
+        diff="%F{green}$(printf "%dms" "$diff")%f"
+    else
+        diff="%F{magenta}$(printf "%dms" "$diff")%f"
+
+    fi
+    # print -n -P "[%F{green}.zlogin%f]"
+fi
+
+if [[ -o interactive ]]; then
+    # Banner
+    echo -e "\033[38;5;5m"
+
+    cat <<EOF
++──                               
+┌──┐ ─── ── ───── ──── ───  ───
+│  │ 
+│  │  │           │  │     
+└──┘──┴──╲        ╱──┴──┴──    
+          ╲      ╱       ╱    
+
+EOF
+    echo -e "\033[0m"
 fi
+print -P "l: [$diff]"
 
 export ZSH_TRACE="$XDG_CONFIG_HOME/zsh/logs/zsh-exec.log"
+
+export PATH="$IMGNX_PATH"
+
+cloudflared -v
diff --git a/.zlogout b/.zlogout
index 7a85ac5..8ff2445 100644
--- a/.zlogout
+++ b/.zlogout
@@ -1,6 +1,6 @@
 # shellcheck shell=zsh
 if [[ -o interactive ]]; then
-    print -n -P "[%F{#8800dd}.zlogout%f]"
+    print -n -P "[%F{red}.zlogout%f]"
 fi
 
 ### ============================
diff --git a/.zprofile b/.zprofile
index dc24c1f..52a445c 100644
--- a/.zprofile
+++ b/.zprofile
@@ -1,15 +1,11 @@
 # shellcheck shell=zsh
 
-if [[ -o interactive ]]; then
-  echo -e "[\033[38;5;2m.zprofile\033[39m]"
-fi
+# if [[ -o interactive ]]; then
+#   print -n -P "[%F{green}.zprofile%f]"
+# fi
 # ============================
 # Plugins and Integrations
 # ============================
-if command -v code >/dev/null 2>&1; then
-  export VSCODE_SUGGEST=1
-  source "$(code --locate-shell-integration-path zsh)"
-fi
 
 if [ -f '/Users/donaldmoore/google-cloud-sdk/path.zsh.inc' ]; then
   . '/Users/donaldmoore/google-cloud-sdk/path.zsh.inc'
@@ -18,5 +14,3 @@ fi
 if [ -f '/Users/donaldmoore/google-cloud-sdk/completion.zsh.inc' ]; then
   . '/Users/donaldmoore/google-cloud-sdk/completion.zsh.inc'
 fi
-
-# print -P "✔︎ %F{yellow}.zprofile%f"
diff --git a/.zshenv b/.zshenv
index 9e1731d..a293815 100644
--- a/.zshenv
+++ b/.zshenv
@@ -1,4 +1,7 @@
-# shellcheck shell=bash
+if [[ "${ZLOADING:-}" == ".zshenv" && "${SKIP_PREFLIGHT_LOAD_CHECK:-0}" != 1 ]]; then
+    print -n -P "[%F{#444}skip%f(%F{white}%D{%S.%3.}%f)]"
+    return 0
+fi
 
 COPILOT_MODE="${COPILOT_MODE:-false}" # Default to false if not set
 
@@ -14,120 +17,49 @@ function import() {
 
 }
 
-# "Tabula rasa" is a Latin term meaning "blank slate".
-# In philosophy and psychology, it refers to the idea
-# that individuals are born without built-in mental
-# content and that all knowledge comes from experience
-# and sensory perception. This concept is central to
-# the empiricist view of learning and development,
-# contrasting with nativism, which suggests that some
-# knowledge is innate.
-# # Tabula Rasa will
-
-# function 1DABF50B_9CB5_4679_9B58_2F203D12C8F1() {
-#     echo -e "Active Mode: \033[38;5;2mNormal\033[0m"
-#     echo -e "Mode(s): \033[38;5;4mScreencast\033[0m, \033[38;5;64mZen Mode\033[39m, \033[38;5;84mTabula Rasa\033[0m, \033[38;5;6mCopilot\033[0m..."
-#     echo -e "Activate? [Y/n]:"
-
-#     read -k 1 init_response
-#     if [[ "$init_response" =~ ^[Yy]$ ]]; then
-
-#         # If screencast mode is set to -1, ask the user if they are screencasting.
-#         if [[ "$SCREENCAST_MODE" -eq -1 ]]; then
-#             # Screencast mode is not set. Do you want to enable it?
-#             # This will allow the terminal to be recorded in screencasts.
-#             # Ask about screencast mode
-#             echo -n " Are you \033[38;5;31mScreencasting\033[0m? [Y/n]:"
-#             # Read only the first character of input
-#             read -k 1 sc_response
-#             # Move to a new line after the keypress
-#             echo
-#             if [[ "$sc_response" =~ ^[Yy]$ ]]; then
-
-#             else
-
-#             fi
-#             clear
-#         else
-#             echo "Screencast mode is currently set to $SCREENCAST_MODE."
-#         fi
-
-#         # Tabula Rasa Mode
-#         if [[ "$TABULA_RASA" -eq -1 ]]; then
-#             # Tabula Rasa mode is not set. Do you want to enable it?
-#             # This will give you a blank slate — no configrations will be loaded.
-#             # Ask about tabula rasa mode
-#             echo -n " \033[38;5;2mTabula Rasa?\033[39m [y/N]: "
-#             read -k 1 tr_response
-#             # Move to a new line after the keypress
-#             echo
-#             if [[ "$tr_response" =~ ^[Yy]$ ]]; then
-
-#             else
-
-#             fi
-
-#             clear
-#             # # Clear the last two lines from the prompt above (the question and the response).
-#             # if [[ -n "$ZSH_VERSION" ]]; then
-#             #     # Zsh-specific way to clear lines
-#             #     print -n "\e[1A\e[2K"
-#             # else
-#             #     # Fallback for other shells (like bash)
-#             #     echo -e "\033[1A\033[2K"
-#             # fi
-#         fi
-#     fi
-# }
-
-# if [[ -o interactive ]]; then
-# 1DABF50B_9CB5_4679_9B58_2F203D12C8F1
-# fi
-
-### 🥾 PATH
-
-function add2path() {
-    $HOME/bin/add2path "$@"
-}
-add2path "$HOME/bin"
-# add2path "$HOME/.local/bin"
-# add2path "$HOME/.cargo/bin"
+if [[ -o interactive ]]; then
+    export ZLOADING=".zshenv"
+    # Uncomment to disable preflight load check
+    # export SKIP_PREFLIGHT_LOAD_CHECK=0
+    echo -e "✅ INTERACTIVE │ l: [\033[38;5;207;3;4m${ZLOADING:-.zshenv}\033[0m] │ pfc: ${SKIP_PREFLIGHT_LOAD_CHECK:-0}"
 
-### 🌐 XDG
+    . "/Users/donaldmoore/.config/zsh/variables.zsh" # Load custom variables
+    export ZDOTDIR="${ZDOTDIR:-$HOME/.config/zsh}"   # Set ZDOTDIR if not already set
+    . "${ZDOTDIR}/functions.zsh"                     # Load custom functions
 
-# cargo config is located in $XDG_CONFIG_HOME/cargo/config.toml
+    # ? To get the path of a `brew` command:
+    # ? brew --prefix cmd
+    export IMGNX_PATH="/Users/donaldmoore/bin:/usr/local/opt:/usr/local/bin:/Users/donaldmoore/.config/cargo/bin:/System/Cryptexes/App/usr/bin:/usr/bin:/bin:/usr/sbin:/sbin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/local/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/appleinternal/bin:/Library/Apple/usr/bin:/usr/local/MacGPG2/bin:/Applications/Wireshark.app/Contents/MacOS"
+    export PATH="$IMGNX_PATH"
+    export IMGNXZINIT=$(($(date +%s) * 1000 + $(date +%N | cut -b1-3)))
 
-for lib_dir in ~/lib/**/build; do
-    add2path "$lib_dir"
-done
+    # VS Code
+    if command -v code >/dev/null 2>&1; then
+        export VSCODE_SUGGEST=1
+    fi
 
-### ✋ Modules
-### source
+    ### 🥾 PATH
 
-### GPG
-if command -v gpgconf >/dev/null 2>&1; then
+    add2path "$HOME/bin"
+    # add2path "$HOME/.local/bin"
+    # add2path "$HOME/.cargo/bin"
 
-fi
-### ZSH
+    ### 🌐 XDG
 
-### No-Name Directory (fallback for plugins)
+    # cargo config is located in $XDG_CONFIG_HOME/cargo/config.toml
 
-. "/Users/donaldmoore/.local/share/cargo/env"
+    for lib_dir in ~/lib/**/build; do
+        add2path "$lib_dir"
+    done
 
-if [[ -o interactive ]]; then
+    ### No-Name Directory (fallback for plugins)
+    # Rust/Cargo
+    . "/Users/donaldmoore/.local/share/cargo/env"
 
-    print -n -P "[%F{green}.zshenv%f]"
-    . "${ZDOTDIR}/variables.zsh" # Load custom variables
-    # ^ is a dependancy of v ...
-    . "${ZDOTDIR}/aliases.zsh" # Load custom aliases
-    # ^ is a dependancy of v ...
-    . "${ZDOTDIR}/functions.zsh" # Load custom functions
-    # ^ is a dependancy of v ...
+    . "${ZDOTDIR}/aliases.zsh"     # Load custom aliases
     . "${ZDOTDIR}/keybindings.zsh" # Load custom keybindings
-    # ^ is a dependancy of v ...
-    . "${ZDOTDIR}/hashes.zsh" # Load custom keybindings
-    # ^ is a dependancy of v ...
-    . "${ZDOTDIR}/path.zsh" # Load custom keybindings
+    . "${ZDOTDIR}/hashes.zsh"      # Load custom hashes
+    . "${ZDOTDIR}/path.zsh"        # Load custom path
     # Source Cargo
     [ -f "$HOME/.config/cargo/env" ] && . "$HOME/.config/cargo/env"
 
@@ -146,3 +78,4 @@ if [[ -o interactive ]]; then
     autoload_usb_config
 
 fi
+. "/Users/donaldmoore/.config/cargo/env"
diff --git a/.zshrc b/.zshrc
index 2228845..d9dc94f 100644
--- a/.zshrc
+++ b/.zshrc
@@ -1,5 +1,10 @@
-if [[ -o interactive ]]; then
-    print -n -P "[%F{green}.zshrc loaded at %D{%Y-%m-%d %H:%M:%S}%f]"
+if [[ "${ZLOADING:-}" == ".zshrc" && "${SKIP_PREFLIGHT_LOAD_CHECK:-0}" != 1 ]]; then
+    print -n -P "[%F{#444}skip%f(%F{white}%D{%S.%3.}%f)]"
+
+    return 0
+else
+    # print -n -P "[%F{green}.zshrc%f]"
+    export ZLOADING=".zshrc"
 fi
 
 if [[ -n "$TABULA_RASA" && "$TABULA_RASA" -eq 1 ]]; then
@@ -46,34 +51,8 @@ fi
 # Better prompt with fixed slash and dimmed path
 # Update prompt dynamically on every directory change
 AAA52195_7126_4ECB_90D6_BCE64B3E0A5F() {
-    PS1='%n%F{magenta}@%f'$LOCAL_IP'
-%F{'$(
-        if git rev-parse --is-inside-work-tree &>/dev/null; then
-            if git diff --quiet --cached &>/dev/null && git diff --quiet &>/dev/null; then
-                if git stash list &>/dev/null && [[ -z $(git stash list) ]]; then
-                    branch_status=$(git status --porcelain=2 --branch)
-                    ahead_count=$(echo "$branch_status" | grep -Eo 'branch.ab \+([0-9]+)' | awk '{print $2}')
-                    behind_count=$(echo "$branch_status" | grep -Eo 'branch.ab -([0-9]+)' | awk '{print $2}')
-
-                    if [ "$ahead_count" -gt 0 ]; then
-                        echo green
-                    elif [ "$ahead_count" -eq 0 ] && [ "$behind_count" -eq 0 ]; then
-                        echo magenta
-                    else
-                        echo green
-                    fi
-                else
-                    echo green
-                fi
-            elif git diff --quiet &>/dev/null; then
-                echo yellow
-            else
-                echo red
-            fi
-        else
-            echo "#444"
-        fi
-    )'}%f %F{magenta}'$(dirname "$PWD" | sed 's|\(.*\)\(.\{20\}\)$|…\2|' || echo '')'%f%F{yellow}'/$(basename "$PWD")'%f%F{cyan} =>%f '
+    PS1='%n%F{#FF1493}@%f'$LOCAL_IP'
+%F{'$(ggs)'}%f %F{#1493FF}'$(dirname "$PWD" | sed 's|\(.*\)\(.\{20\}\)$|…\2|' || echo '')'%f%F{yellow}'/$(basename "$PWD")'%f %B=>%b '
 }
 
 # test
@@ -85,19 +64,6 @@ SYSLINE_CACHE="$CACHE_DIR/sysline_cache"
 
 # --- Interactive-Only ---
 if [[ -o interactive ]]; then
-    # Banner
-    echo -e "\033[38;5;5m"
-
-    cat <<EOF
-+__                               
-┌  ┐ ___     _____ ____ ___  ___
-│  │/   │__ /  ___\    \\\\  \/  /
-│  │  │    +  /_/   │  │     
-└──┘──│──\  \     /──│──│──/\  \\
-          \──────/           \──\\
-EOF
-    echo -e "\033[0m"
-
     # Hooks
     if ! [[ "${precmd_functions[*]}" == *_IMGNX_* ]]; then
         if typeset -f add-zsh-hook >/dev/null 2>&1; then
diff --git a/aliases.zsh b/aliases.zsh
index 874e240..142565a 100644
--- a/aliases.zsh
+++ b/aliases.zsh
@@ -1,98 +1,94 @@
 # shellcheck shell=bash
 
-print -n -P "[%F{#202020}aliases%f]"
+print -n -P "[%F{green}aliases%f]"
 
-alias _re="_reset"
-alias _reset="command reset"
-alias .......='cd ../../../../../..'
-alias ......='cd ../../../../..'
-alias .....='cd ../../../..'
-alias ....='cd ../../..'
-alias ...='cd ../..'
-alias ..='cd ..'
-alias 0bsd="license"
-alias b="cd ~/bin"
-alias bkgd='afplay "$BKGD" &'
-alias cash="$money"
-alias cdspc='codespace'
-alias clean-precmd="precmd_functions=()"
-alias cnt="cd ~/src"
-alias dw="$DOWNLOADS"
-alias dwn="$DOWNLOADS"
-alias e='emacs'
-alias edit='emacs'
-alias ga='git add'
-alias gb='git branch'
-alias gc='git commit'
-alias gco='git checkout'
-alias gd='git diff'
-alias git-branch="git branch -v"
-alias git-remote="git remote -v"
-alias gl='git pull'
-alias gp='git push'
-
-alias gs='git status'
-alias h='history'
-alias i=$ICLOUD_DRIVE
-alias icloud=$ICLOUD_DRIVE
-alias imgnxlog=" 70960C40-F14F-49E5-ABE6-EACEAE25F79B $@"
-alias l.="eza -a | grep -E '^\.'"
+# ============================
+# Screencast Mode Aliases
+# ============================
+# Screencast mode - clean, minimal output, no secrets or hidden details
+alias ls='eza -bGF --header --git --color=always --group-directories-first --icons'
+alias ll='eza -la --icons --group-directories-first'
 alias l='eza -bGF --header --git --color=always --group-directories-first --icons'
 alias la='eza --long --all --group --group-directories-first'
 alias ld='eza -1 --color=always --group-directories-first --icons'
-alias lh="eza -a | grep -E '^\.'"
-alias list-hooks="echo 'All hooks:'; echo 'precmd:' \"\${precmd_functions[@]}\"; echo 'preexec:' \"\${preexec_functions[@]}\"; echo 'periodic:' \"\${periodic_functions[@]}\""
-alias list-precmd="echo 'precmd_functions:'; printf '%s\n' \"\${precmd_functions[@]}\""
-alias ll='eza -la --icons --octal-permissions --group-directories-first'
+alias l.="eza -a | grep -E '^\.'"
+alias lh="eza -a | grep -E '^\.|^total'"
 alias llm='eza -lbGd --header --git --sort=modified --color=always --group-directories-first --icons'
 alias lx='eza -lbhHigUmuSa@ --time-style=long-iso --git --color-scale --color=always --group-directories-first --icons'
-alias m='"$MEDIA"'
-alias mkdir='mkdir -p'
-alias money='"$HOME/Library/Mobile Documents/com~apple~CloudDocs/_____WORKBENCH/src/utils/financial/calculator"'
-alias pip="python -m pip"
-alias pro="edit $ZDOTDIR/.zprofile"
-alias re='reset'                   # alias for reset
-alias refresh='reset'              # alias for reset
-alias reset='reset && exec zsh -l' # reset terminal in interactive mode.
-alias restart='reset'              # alias for reset
-alias rp=realpath
-alias s='cd ~/src'
-alias sam=$SAMPLES
-alias scr=$SCRIPTS
-alias sexy="open https://terminal.sexy/"
-alias SURGE="$HOME/Library/Containers/com.apple.garageband10/Data/Documents/Surge XT/Patches/Templates"
-alias sync_icloud="isync"
-alias t='cd ~/test'
-alias tk=$TAKU
-alias tr="+tabula_rasa"
-alias ttr="+tabula_rasa"
-alias x="sexy"
-alias xdg-open="open"
+alias lsd='eza -d --color=always --group-directories-first --icons'
+alias lsd.="eza -d -a | grep -E '^\.'"
+alias lsdh="eza -d | grep -E '^\.'"
+alias lsdh.="eza -d -a | grep -E '^\.'"
+alias df='df -h'
+alias top='top -o cpu'
 
-# ============================
-# Screencast Mode Aliases
-# ============================
-if [ "$SCREENCAST_MODE" = 1 ]; then
-    # Screencast mode - clean, minimal output, no secrets or hidden details
-    alias ls='eza -bGF --header --git --color=always --group-directories-first --icons'
-    alias ll='eza -la --icons --group-directories-first'
+if [ "$SCREENCAST_MODE" != 1 ]; then
+    # Normal mode - verbose, detailed output with all information
+    alias _re="_reset"
+    alias _reset="command reset"
+    alias .......='cd ../../../../../..'
+    alias ......='cd ../../../../..'
+    alias .....='cd ../../../..'
+    alias ....='cd ../../..'
+    alias ...='cd ../..'
+    alias ..='cd ..'
+    alias 0bsd="license"
+    alias b="cd ~/bin"
+    alias bkgd='afplay "$BKGD" &'
+    alias cash="$money"
+    alias cdspc='codespace'
+    alias clean-precmd="precmd_functions=()"
+    alias cnt="cd ~/src"
+    alias dw="$DOWNLOADS"
+    alias dwn="$DOWNLOADS"
+    alias e='emacs'
+    alias edit='emacs'
+    alias ga='git add'
+    alias gb='git branch'
+    alias gc='git commit'
+    alias gco='git checkout'
+    alias gd='git diff'
+    alias git-branch="git branch -v"
+    alias git-remote="git remote -v"
+    alias gl='git pull'
+    alias gp='git push'
+    alias grep='rg'
+    alias gs='git status'
+    alias h='history'
+    alias i=$ICLOUD_DRIVE
+    alias icloud=$ICLOUD_DRIVE
+    alias imgnxlog=" 70960C40-F14F-49E5-ABE6-EACEAE25F79B $@"
+    alias l.="eza -a | grep -E '^\.'"
     alias l='eza -bGF --header --git --color=always --group-directories-first --icons'
     alias la='eza --long --all --group --group-directories-first'
     alias ld='eza -1 --color=always --group-directories-first --icons'
-    alias l.="eza -a | grep -E '^\.'"
-    alias lh="eza -a | grep -E '^\.|^total'"
+    alias lh="eza -a | grep -E '^\.'"
+    alias list-hooks="echo 'All hooks:'; echo 'precmd:' \"\${precmd_functions[@]}\"; echo 'preexec:' \"\${preexec_functions[@]}\"; echo 'periodic:' \"\${periodic_functions[@]}\""
+    alias list-precmd="echo 'precmd_functions:'; printf '%s\n' \"\${precmd_functions[@]}\""
+    alias ll='eza -la --icons --octal-permissions --group-directories-first'
     alias llm='eza -lbGd --header --git --sort=modified --color=always --group-directories-first --icons'
     alias lx='eza -lbhHigUmuSa@ --time-style=long-iso --git --color-scale --color=always --group-directories-first --icons'
-    alias lsd='eza -d --color=always --group-directories-first --icons'
-    alias lsd.="eza -d -a | grep -E '^\.'"
-    alias lsdh="eza -d | grep -E '^\.'"
-    alias lsdh.="eza -d -a | grep -E '^\.'"
-    alias df='df -h'
-    # alias du='du -h'
-    # alias ps='ps aux'
-    alias top='top -o cpu'
-else
-    # Normal mode - verbose, detailed output with all information
+    alias m='"$MEDIA"'
+    alias mkdir='mkdir -p'
+    alias money='"$HOME/Library/Mobile Documents/com~apple~CloudDocs/_____WORKBENCH/src/utils/financial/calculator"'
+    alias pip="python -m pip"
+    alias re='reset'                   # alias for reset
+    alias refresh='reset'              # alias for reset
+    alias reset='reset && exec zsh -l' # reset terminal in interactive mode.
+    alias restart='reset'              # alias for reset
+    alias rp=realpath
+    alias s='cd ~/src'
+    alias sam=$SAMPLES
+    alias scr=$SCRIPTS
+    alias sexy="open https://terminal.sexy/"
+    alias SURGE="$HOME/Library/Containers/com.apple.garageband10/Data/Documents/Surge XT/Patches/Templates"
+    alias sync_icloud="isync"
+    alias t='cd ~/test'
+    alias tk=$TAKU
+    alias tr="tabula_rasa"
+    alias ttr="tabula_rasa"
+    alias x="sexy"
+    alias xdg-open="open"
     alias df='df -ahicY'                                          # All filesystems, human readable, inodes, show type
     alias top='top -o cpu -stats pid,command,cpu,mem,pstate,time' # Detailed process info
     alias free='vm_stat'                                          # Memory usage details on macOS
diff --git a/functions.zsh b/functions.zsh
index 4075ae4..e340d7d 100644
--- a/functions.zsh
+++ b/functions.zsh
@@ -1,12 +1,44 @@
-#!/bin/zsh
# shellcheck disable=SC1071

-# shellcheck shell=zsh
+#!/bin/zsh
+#shellcheck shell=sh
 
-print -n -P "[%F{green}${ZDOTDIR}/functions.sh%f]"
+# Get the path of the current script
+script_path="${0}"
+
+echo "$PATH" | grep -q "/Users/donaldmoore/bin" || export PATH="$HOME/bin:$PATH"
+
+# Print the size of the current file.
+print -n -P "[%F{green}functions%f($(command stat -f %z "$0" | numfmt --to=iec --suffix=B))]"
 
 # Declare associative array for TODO cache
 typeset -gA __TODO_CACHE
+shellcheck() {
+	if cat "$1" | grep -q '^#!.*zsh'; then
+		echo "zsh -n \"$1\""
+		output=$(zsh -n "$1")
+		if [[ -n "$output" ]]; then
+			echo -e "❌ \033[38;5;1mFound issues:\033[0m"
+			echo "$output"
+		else
+			echo -e "✅ \033[38;5;2mNo issues found by shellcheck.\033[0m"
+		fi
+	else
+		command shellcheck "$1" 2>&1
+	fi
 
-toggle_tabula_rasa() {
+}
+add2path() {
+	# Add a directory to the PATH if it's not already present
+	local dir="$1"
+	if [[ ! -d "$dir" ]]; then
+		echo -e "\033[38;5;1madd2path: Directory '$dir' does not exist. Skipping PATH addition.\033[0m"
+		return
+	fi
+	if [[ ":$PATH:" != *":$dir:"* ]]; then
+		export PATH="$dir:$PATH"
+	fi
+}
+
+tabula_rasa() {
 	if [[ -z "$TABULA_RASA" ]]; then
 		export TABULA_RASA=1
 		echo "Tabula Rasa mode is enabled. No configurations will be loaded."
@@ -51,21 +83,21 @@ imgnx_debug() {
 	history >"$HOME/+imgnx/command_history.txt"
 	echo "All debug information has been saved to $HOME/+imgnx/."
 }
-F6596432_CA98_4A50_9972_E10B0EE99CE9() {
-	local mtime
-	if [[ "$OSTYPE" == darwin* ]]; then
-		mtime=$(stat -f %m "$SYSLINE_CACHE" 2>/dev/null)
-	else
-		mtime=$(stat -c %Y "$SYSLINE_CACHE" 2>/dev/null)
-	fi
-	local now=$(date +%s)
-	if [ -n "$mtime" ] && [ "$mtime" -lt $((now - 10)) ]; then
-		6D078F25_9FBE_4352_A453_71F7947A3B01
-	fi
-	local sysline=""
-	[ -f "$SYSLINE_CACHE" ] && sysline=$(<"$SYSLINE_CACHE")
-	print -P "$(colorize \n$sysline)"
-}
+# F6596432_CA98_4A50_9972_E10B0EE99CE9() {
+# 	local mtime
+# 	if [[ "$OSTYPE" == darwin* ]]; then
+# 		mtime=$(stat -f %m "$SYSLINE_CACHE" 2>/dev/null)
+# 	else
+# 		mtime=$(stat -c %Y "$SYSLINE_CACHE" 2>/dev/null)
+# 	fi
+# 	local now=$(date +%s)
+# 	if [ -n "$mtime" ] && [ "$mtime" -lt $((now - 10)) ]; then
+# 		6D078F25_9FBE_4352_A453_71F7947A3B01
+# 	fi
+# 	local sysline=""
+# 	[ -f "$SYSLINE_CACHE" ] && sysline=$(<"$SYSLINE_CACHE")
+# 	print -P "$(colorize \n$sysline)"
+# }
 autoload_usb_config() {
 	for vol in /Volumes/*; do
 		if [[ -d "$vol" && -d "$vol/.config" ]]; then
@@ -87,8 +119,8 @@ brew() {
 }
 cd() {
 	builtin cd "$@" || return
-	__TODO_CACHE[$PWD]=""
-	ls
+	__TODO_CACHE[$PWD]="" || return
+	ls || return
 }
 # clean-hooks() {
 # 	echo "Current hooks:"
@@ -105,21 +137,56 @@ cd() {
 # 	code -r "$WORKSPACE/.vscode/Workbench.code-workspace"
 # }
 colorize() {
-	local AWKDIR="$HOME/.config/zsh/functions"
-	if [[ "$1" == "-b" || "$1" == "--background" ]]; then
-		shift
-		echo "$*" | gawk -f "$AWKDIR/colorize.bkgd.awk"
-	elif [[ "$1" == "-f" || "$1" == "--foreground" ]]; then
-		shift
-		echo "$*" | gawk -f "$AWKDIR/colorize.fore.awk"
-	elif [[ "$1" == "-h" || "$1" == "--help" ]]; then
-		echo "Usage: colorize [-b|--background] [-f|--foreground] <text>"
+	if [[ "$1" == "-h" || "$1" == "--help" ]]; then
+		echo "Usage: colorize [~|--foreground] [|--background] <text>"
 		echo "Options:"
-		echo "  -b, --background   Colorize text with background colors"
-		echo "  -f, --foreground   Colorize text with foreground colors"
+		echo "  ~, --foreground   Colorize text with foreground colors"
+		echo "  |, --background   Colorize text with background colors"
 		echo "  -h, --help         Show this help message"
 	else
-		echo "$*" | gawk -f "$AWKDIR/colorize.awk"
+		gawk 'BEGIN {
+			# Initialize colors
+			for (i = 0; i < 256; i++) {
+				if (i == 0 || i == 15 || i == 231 || i == 255) continue; # Skip black and white
+				r = int((i / 36) % 6) * 51; # Red component
+				g = int((i / 6) % 6) * 51;  # Green component
+				b = int(i % 6) * 51;        # Blue component
+				hex = sprintf("#%02X%02X%02X", r, g, b);
+				fgcolors[i] = "%F{" hex "}";
+				bgcolors[i] = "%K{" hex "}";
+			}
+			reset_fg = "%f";
+			reset_bg = "%k";
+		}
+		{
+			# Split input into segments by ~ and |
+			n = split($0, segs, /[~|]/);
+			out = "";
+			fg_idx = 0;
+			bg_idx = 0;
+			for (i = 1; i <= n; i++) {
+				if (match($0, "~")) {
+					if (fg_idx < 256) {
+						color = fgcolors[fg_idx++];
+						out = out color segs[i] reset_fg;
+					} else {
+						out = out "~" segs[i];
+					}
+				} else if (match($0, "|")) {
+					if (bg_idx < 256) {
+						color = bgcolors[bg_idx++];
+						out = out color segs[i] reset_bg;
+					} else {
+						out = out "|" segs[i];
+					}
+				} else {
+					out = out segs[i];
+				}
+			}
+			print out;
+		}' <<<"$*" | while IFS= read -r line; do
+			print -P -- "$line"
+		done
 	fi
 }
 
@@ -266,10 +333,6 @@ k() {
 labs() {
 	cd $LABS
 }
-license() {
-	echo "Writing LICENSE file..."
-	cat ~/LICENSE | tee ./LICENSE
-}
 media() {
 	cd $MEDIA
 }
@@ -497,19 +560,19 @@ function 6D078F25_9FBE_4352_A453_71F7947A3B01() {
 	fi
 	ZSH_COUNT=$(pgrep -c zsh 2>/dev/null || ps -eo comm | grep -c "^zsh")
 	if [[ $ZSH_COUNT -gt 30 ]]; then
-		CONCURRENT_SHELLS="%K{#FF2000}%F{white} No. ${ZSH_COUNT} %f%k"
+		CONCURRENT_SHELLS="%F{#FF2000} ${ZSH_COUNT} %f"
 	elif [[ $ZSH_COUNT -gt 20 ]]; then
-		CONCURRENT_SHELLS="%K{#FF8000}%F{white} No. ${ZSH_COUNT} %f%k"
+		CONCURRENT_SHELLS="%F{#FF8000} ${ZSH_COUNT} %f"
 	elif [[ $ZSH_COUNT -gt 15 ]]; then
-		CONCURRENT_SHELLS="%K{#FFFF00}%F{white} No. ${ZSH_COUNT} %f%k"
+		CONCURRENT_SHELLS="%F{#FFFF00} ${ZSH_COUNT} %f"
 	elif [[ $ZSH_COUNT -gt 10 ]]; then
-		CONCURRENT_SHELLS="%K{#80FF00}%F{white} No. ${ZSH_COUNT} %f%k"
+		CONCURRENT_SHELLS="%F{#80FF00} ${ZSH_COUNT} %f"
 	else
-		CONCURRENT_SHELLS="%K{black}%F{white} No. ${ZSH_COUNT} %f%k"
+		CONCURRENT_SHELLS="%F{#4400CC} ${ZSH_COUNT} %f"
 	fi
 
 	# Newline for sparsity
-	echo -e "ID:| $CONCURRENT_SHELLS |\tCPU:| %K{black} ${CPU_USAGE}%% %k|\tRAM:| %K{black} ${RAM}MB %k" >"$SYSLINE_CACHE"
+	echo -e "~zQt:| ${CONCURRENT_SHELLS} |~\tCPU:| ${CPU_USAGE}%% |~\tRAM:| ${RAM}MB" >"$SYSLINE_CACHE"
 }
 
 # Prompt
@@ -529,5 +592,74 @@ function F6596432_CA98_4A50_9972_E10B0EE99CE9() {
 	[[ -f $SYSLINE_CACHE ]] && sysline=$(<"$SYSLINE_CACHE")
 
 	# Ensure a newline before sysline block
-	print -P "$(colorize \n$sysline)"
+	colorize $sysline
+}
+
+# Custom ls function with git status coloring
+statusls() {
+	# Check if we're in a git repository
+	if git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
+		# Set up XDG cache directory
+		local cache_dir="${XDG_CACHE_HOME:-$HOME/.cache}/ls-git-colors"
+		mkdir -p "$cache_dir"
+
+		# Create unique cache file based on current directory and ls arguments
+		local cache_key=$(echo "$PWD $*" | sha256sum | cut -d' ' -f1)
+		local ls_cache_file="$cache_dir/ls_output_${cache_key}"
+		local git_cache_file="$cache_dir/git_info_${cache_key}"
+
+		# Get git information efficiently
+		local git_status_output=$(git status --porcelain 2>/dev/null)
+		local git_tracked_output=$(git ls-files 2>/dev/null)
+
+		# Cache the original ls output
+		/bin/ls "$@" 2>/dev/null >"$ls_cache_file"
+
+		# Read the cached output
+		local ls_output=$(<"$ls_cache_file")
+		local colored_output="$ls_output"
+
+		# Process each actual file in the directory
+		for file in *; do
+			[[ ! -e "$file" ]] && continue
+
+			local color=""
+			local reset=$'\033[0m'
+
+			if echo "$git_tracked_output" | grep -q "^${file}$"; then
+				# File is tracked - check for modifications
+				if echo "$git_status_output" | grep -q "^.M ${file}$\|^M. ${file}$"; then
+					color=$'\033[33m' # Modified - yellow
+				elif echo "$git_status_output" | grep -q "^A. ${file}$"; then
+					color=$'\033[32m' # Added - green
+				elif echo "$git_status_output" | grep -q "^.D ${file}$\|^D. ${file}$"; then
+					color=$'\033[31m' # Deleted - red
+				else
+					color=$'\033[32m' # Tracked and clean - green
+				fi
+			elif echo "$git_status_output" | grep -q "^?? ${file}$"; then
+				color=$'\033[31m' # Untracked - red
+			fi
+
+			# Apply color if we have one - use awk for precise matching
+			if [[ -n "$color" ]]; then
+				colored_output=$(echo "$colored_output" | awk -v file="$file" -v color="$color" -v reset="$reset" '
+					{
+						# Split line into fields and reconstruct with colors
+						line = $0
+						gsub("\\<" file "\\>", color file reset, line)
+						print line
+					}
+				')
+			fi
+		done
+
+		# Clean up cache files
+		rm -f "$ls_cache_file" "$git_cache_file"
+
+		echo "$colored_output"
+	else
+		# Not in a git repository, use normal ls
+		/bin/ls "$@"
+	fi
 }
diff --git a/functions/colorize.awk b/functions/colorize.awk
index c317910..0fa9cbb 100644
--- a/functions/colorize.awk
+++ b/functions/colorize.awk
@@ -3,26 +3,24 @@
 
 # This script colorizes the text between pipes in a file.
 # It uses ANSI escape codes to set the text color.
-# The colors are cycled through three different colors:
-# magenta, yellow, and cyan.
+# The colors are cycled through 8-bit ANSI colors (0-255).
 
 
 BEGIN {
-    colors [0] = "\033[1;35m";    # magenta
-    colors [1] = "\033[1;33m";    # yellow
-    colors [2] = "\033[1;36m";    # cyan
+    for (i = 0; i < 256; i++) {
+        colors[i] = sprintf("\033[38;5;%dm", i); # 8-bit ANSI color
+    }
     reset = "\033[0m";
     color_idx = 0;
 }
 {
     line = $0;
-    while ( match( line, /\|[^|]+\|/ ) ) {
-        color = colors [ color_idx % 3 ];
+    while (match(line, /\|[^|]+\|/)) {
+        color = colors[color_idx % 256];
         color_idx++;
-        match_str = substr( line, RSTART + 1, RLENGTH- 2 );
-        repl      = color match_str reset;
-        line = substr(line, 1, RSTART - 1) repl substr(line, RSTART + RLENGTH)
-
+        match_str = substr(line, RSTART + 1, RLENGTH - 2);
+        repl = color match_str reset;
+        line = substr(line, 1, RSTART - 1) repl substr(line, RSTART + RLENGTH);
     }
     print line;
 }
diff --git a/functions/colorize.bkgd.awk b/functions/colorize.bkgd.awk
index ebca4ad..201876d 100755
--- a/functions/colorize.bkgd.awk
+++ b/functions/colorize.bkgd.awk
@@ -4,47 +4,26 @@
 # Usage:
 #   echo "foo |bar| baz" | gawk -f background-colorize.awk
 
-function hex2zsh_bg(hex) {
-    if (substr(hex,1,1) != "#") hex = "#" hex
-    return "%K{" hex "}"
-}
-
 BEGIN {
-    # Background only
-    hexcolors[0] = "#FF00FF"; # magenta
-    hexcolors[1] = "#FFFF00"; # yellow
-    hexcolors[2] = "#00FFFF"; # cyan
-    hexcolors[3] = "#FF0000"; # red
-    hexcolors[4] = "#00FF00"; # green
-    hexcolors[5] = "#0000FF"; # blue
-    hexcolors[6] = "#FFFFFF"; # white
-    hexcolors[7] = "#000000"; # black
-    hexcolors[8] = "#808080";
-    hexcolors[9] = "#800000";
-    hexcolors[10] ="#008000";
-    hexcolors[11] ="#000080";
-    hexcolors[12] ="#808000";
-    hexcolors[13] ="#800080";
-    hexcolors[14] ="#008080";
-    hexcolors[15] ="#C0C0C0";
-
-    color_count = 16;
-    for (i = 0; i < color_count; i++) {
-        bgcolors[i] = hex2zsh_bg(hexcolors[i]);
+    for (i = 0; i < 256; i++) {
+        bgcolors[i] = sprintf("\033[48;5;%dm", i); # 8-bit ANSI background color
     }
-    reset_bg = "%k";
+    reset_bg = "\033[0m";
+    color_idx = 0;
 }
 {
-    n = split($0, segs, "|");
-    out = "";
-    for (i = 1; i <= n; i++) {
-        # Preserve pre-colored segments
-        if (segs[i] ~ /%[K]\{#[0-9A-Fa-f]{6}\}/) {
-            out = out segs[i];
-        } else {
-            color = bgcolors[(i-1)%color_count];
-            out = out color segs[i] reset_bg;
-        }
+    line = $0;
+    while (match(line, /\|[^|]+\|/)) {
+        color = bgcolors[color_idx % 256];
+        color_idx++;
+        match_str = substr(line, RSTART + 1, RLENGTH - 2);
+        repl = color match_str reset_bg;
+        line = substr(line, 1, RSTART - 1) repl substr(line, RSTART + RLENGTH);
     }
-    print out;
+    print line;
+}
+
+END {
+    # Reset background color at the end
+    print reset_bg;
 }
diff --git a/functions/colorize.fore.awk b/functions/colorize.fore.awk
index f3dd645..ad9e073 100755
--- a/functions/colorize.fore.awk
+++ b/functions/colorize.fore.awk
@@ -1,50 +1,76 @@
 #!/usr/bin/env gawk -f
-# foreground-colorize.awk - Foreground-only Zsh colorizer
+# colorize.awk - Enhanced Foreground and Background Zsh colorizer
 
 # Usage:
-#   echo "foo |bar| baz" | gawk -f foreground-colorize.awk
+#   echo "text ~foreground |background" | gawk -f colorize.awk
 
 function hex2zsh_fg(hex) {
     if (substr(hex,1,1) != "#") hex = "#" hex
     return "%F{" hex "}"
 }
 
-BEGIN {
-    # Foreground only
-    hexcolors[0] = "#FF00FF"; # magenta
-    hexcolors[1] = "#FFFF00"; # yellow
-    hexcolors[2] = "#00FFFF"; # cyan
-    hexcolors[3] = "#FF0000"; # red
-    hexcolors[4] = "#00FF00"; # green
-    hexcolors[5] = "#0000FF"; # blue
-    hexcolors[6] = "#FFFFFF"; # white
-    hexcolors[7] = "#000000"; # black
-    hexcolors[8] = "#808080";
-    hexcolors[9] = "#800000";
-    hexcolors[10] ="#008000";
-    hexcolors[11] ="#000080";
-    hexcolors[12] ="#808000";
-    hexcolors[13] ="#800080";
-    hexcolors[14] ="#008080";
-    hexcolors[15] ="#C0C0C0";
+function hex2zsh_bg(hex) {
+    if (substr(hex,1,1) != "#") hex = "#" hex
+    return "%K{" hex "}"
+}
+
+function generate_ansi_colors() {
+    # Generate 8-bit ANSI colors (0-255), excluding black and white
+    for (i = 0; i < 256; i++) {
+        if (i == 0 || i == 15 || i == 231 || i == 255) {
+            continue; # Skip black and white
+        }
+        r = int((i / 36) % 6) * 51; # Red component
+        g = int((i / 6) % 6) * 51;  # Green component
+        b = int(i % 6) * 51;        # Blue component
+        hex = sprintf("#%02X%02X%02X", r, g, b);
+        fgcolors[i] = hex2zsh_fg(hex);
+        bgcolors[i] = hex2zsh_bg(hex);
+    }
+    color_count = 256 - 4; # Adjust count to exclude skipped colors
+}
 
-    color_count = 16;
-    for (i = 0; i < color_count; i++) {
-        fgcolors[i] = hex2zsh_fg(hexcolors[i]);
+BEGIN {
+    # Initialize colors and cache
+    cache_file = "/tmp/colorize_cache.txt";
+    if (system("test -f " cache_file) == 0) {
+        system("rm -f " cache_file);
     }
+    generate_ansi_colors();
     reset_fg = "%f";
+    reset_bg = "%k";
 }
 {
-    n = split($0, segs, "|");
+    n = split($0, segs, /[~|]/);
     out = "";
+    fg_idx = 0;
+    bg_idx = 0;
     for (i = 1; i <= n; i++) {
-        # Preserve pre-colored segments
-        # if (segs[i] ~ /%[F]\{#[0-9A-Fa-f]{6}\}/) {
-        #     out = out segs[i];
-        # } else {
-            color = fgcolors[(i-1)%color_count];
-            out = out color segs[i] reset_fg;
-        # }
+        if (match($0, "~")) {
+            if (fg_idx < color_count) {
+                color = fgcolors[fg_idx++];
+                out = out color segs[i] reset_fg;
+            } else {
+                out = out "~" segs[i];
+            }
+        } else if (match($0, "|")) {
+            if (bg_idx < color_count) {
+                color = bgcolors[bg_idx++];
+                out = out color segs[i] reset_bg;
+            } else {
+                out = out "|" segs[i];
+            }
+        } else {
+            out = out segs[i];
+        }
     }
+    print out > cache_file;
     print out;
 }
+
+END {
+    # Clean up cache
+    if (system("test -f " cache_file) == 0) {
+        system("rm -f " cache_file);
+    }
+}
diff --git a/path.zsh b/path.zsh
index 5bb889c..f357fc3 100644
--- a/path.zsh
+++ b/path.zsh
@@ -1,9 +1,9 @@
 print -n -P "[%F{green}path%f]"
 
+$HOME/bin/add2path "$HOME/bin"
 add2path "$BIN"
 add2path "$CARGO_HOME"
 add2path "$CARGO_HOME/bin"
-add2path "$HOME/bin"
 add2path "$HOME/go/bin"
 add2path "$RUSTUP_HOME"
 add2path "$XDG_CONFIG_HOME/cargo/bin"
diff --git a/test_shellcheck.sh b/test_shellcheck.sh
new file mode 100644
index 0000000..da049c4
--- /dev/null
+++ b/test_shellcheck.sh
@@ -0,0 +1,2 @@
+#!/bin/bash
+echo "Hello world"
diff --git a/variables.zsh b/variables.zsh
index 5dfa410..0ffe84c 100644
--- a/variables.zsh
+++ b/variables.zsh
@@ -54,7 +54,7 @@ if [[ "$TABULA_RASA" == "1" ]]; then
     return
 fi
 
-print -n -P "[%F{#202020}variables%f]"
+print -n -P "[%F{green}variables%f]"
 # ============================
 # Named Directories
 hash -d Labs=$LABS
