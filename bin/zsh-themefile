#!/bin/zsh
#shellcheck disable=all

autoload -Uz add-zsh-hook

# Prevent double-loading.
[[ -n "${ZSH_THEMEFILE_LOADED:-}" ]] && return
ZSH_THEMEFILE_LOADED=1

THEMEFILE() {
	local dir="${1:-$PWD}"
	echo "$(realpath "$dir")/.themefile"
}

rHex() {
	local r g b
	r=$((RANDOM % 156 + 50))
	g=$((RANDOM % 156 + 50))
	b=$((RANDOM % 156 + 50))
	printf '#%02X%02X%02X\n' $r $g $b
}

is_hex() {
	local c="${1#\#}"
	[[ "$c" =~ ^[0-9A-Fa-f]{6}$ || "$c" =~ ^[0-9A-Fa-f]{3}$ ]]
}

normalize_hex() {
	local c="${1#\#}"
	if [[ ${#c} -eq 3 ]]; then
		c="${c[1]}${c[1]}${c[2]}${c[2]}${c[3]}${c[3]}"
	fi
	echo "#${c:u}"
}

apply_theme_vars() {
	export COLOR_VAR="$1"
	export FG_VAR="%F{$COLOR_VAR}"
	export BG_VAR="%K{$COLOR_VAR}"
	export THEME_COLOR="$COLOR_VAR"
}

PROMPT_COLOR() {
	local input="$1"
	while true; do
		[[ -z "$input" ]] && {
			echo -n "Insert Hex (#RRGGBB): "
			read -r input
		}
		is_hex "$input" || {
			echo $'%F{yellow}Invalid hex color.%f'
			input=""
			continue
		}
		apply_theme_vars "$(normalize_hex "$input")"
		return 0
	done
}
alias PC=PROMPT_COLOR

NAMESPACE() { export NAMESPACE="$*"; }
alias NS=NAMESPACE

save_themefile() {
	local file="$(THEMEFILE)"
	local -a extras

	if [[ -f "$file" ]]; then
		local line
		while IFS= read -r line; do
			[[ "$line" == COLOR=* || "$line" == NAMESPACE=* || -z "$line" ]] && continue
			extras+=("$line")
		done <"$file"
	fi

	{
		echo "COLOR=$COLOR_VAR"
		echo "NAMESPACE=$NAMESPACE"
		((${#extras[@]})) && printf '%s\n' "${extras[@]}"
	} >|"$file"
}

load_themefile() {
	local file="$(THEMEFILE)"
	[[ -f "$file" ]] || return 0
	while IFS='=' read -r k v; do
		case "$k" in
		COLOR) apply_theme_vars "$v" ;;
		NAMESPACE) export NAMESPACE="$v" ;;
		esac
	done <"$file"
}

THEME() {
	PROMPT_COLOR "$1" || return 1
	shift
	NAMESPACE "$*"
	save_themefile
	echo $'%F{yellow}Use at your own risk.%f'
}

THEME_ROLL() {
	apply_theme_vars "$(rHex)"
	print -P $'%F{green}Applied random theme (not saved).%f'
}

SET_THEME() {
	local file="$1"
	if [[ -z "$file" || ! -f "$file" ]]; then
		echo $'%F{red}Usage: SET_THEME /path/to/.themefile%f'
		return 1
	fi
	local dir="$(dirname "$file")"
	NAMESPACE "${dir:t}"
	while IFS='=' read -r k v; do
		case "$k" in
		COLOR) apply_theme_vars "$v" ;;
		NAMESPACE) NAMESPACE "$v" ;;
		esac
	done <"$file"
	save_themefile
	echo $'%F{green}Loaded theme from%f' "$file"
}

THEME_INIT() {
	local color ns
	color="${1:-$COLOR_VAR}"
	ns="${2:-$NAMESPACE}"

	if [[ -z "${1:-}" ]]; then
		print -n -- "Theme color [${color}]: "
		IFS= read -r reply_color
		[[ -n "$reply_color" ]] && color="$reply_color"
	fi
	if [[ -z "${2:-}" ]]; then
		print -n -- "Namespace [${ns}]: "
		IFS= read -r reply_ns
		[[ -n "$reply_ns" ]] && ns="$reply_ns"
	fi

	is_hex "$color" || {
		echo $'%F{red}Invalid color. Use #RRGGBB.%f'
		return 1
	}
	apply_theme_vars "$(normalize_hex "$color")"
	NAMESPACE "$ns"
	save_themefile
	echo $'%F{green}Wrote theme to .themefile in this directory.%f'
}

THEMEEDIT() {
	local f="$(THEMEFILE)"
	touch "$f"
	${EDITOR:-vi} "$f"
	load_themefile
}

autoThemeFile() {
	(( $+functions[load_themefile] )) || return 0
	load_themefile
}

seza() {
	emulate -L zsh
	setopt pipefail

	local themefile
	if (( $+functions[THEMEFILE] )); then
		themefile="$(THEMEFILE)"
	else
		themefile="${THEMEFILE:-$HOME/.themefile}"
	fi
	[[ -f "$themefile" ]] && source "$themefile"

	local seza_theme_color="${THEME_COLOR:-${COLOR_VAR:-}}"
	local seza_theme_icon=""
	if [[ -n "${SEZA_ICON:-}" ]]; then
		seza_theme_icon="$SEZA_ICON"
	elif [[ -n "${SEZA_NAMESPACE_ICON:-}" ]]; then
		seza_theme_icon="$SEZA_NAMESPACE_ICON"
	elif [[ -n "${NAMESPACE:-}" ]]; then
		seza_theme_icon="$NAMESPACE"
	fi

	if ! command -v eza >/dev/null 2>&1; then
		print -u2 "seza: eza is not installed"
		return 127
	fi

	local -a pairs
	local k v
	if typeset -p EZA_SPECIAL >/dev/null 2>&1; then
		if [[ "$(typeset -p EZA_SPECIAL 2>/dev/null)" == *"-A"* ]]; then
			typeset -A EZA_SPECIAL
			local -a __eza_special_keys=()
			eval '__eza_special_keys=("${(@k)EZA_SPECIAL}")'
			for k in "${__eza_special_keys[@]}"; do
				v="${EZA_SPECIAL[$k]}"
				pairs+=("${k}=${v}")
			done
		else
			for k in "${EZA_SPECIAL[@]}"; do
				pairs+=("$k")
			done
		fi
	fi

	if [[ -n "$seza_theme_color" ]]; then
		local cwd_base="${PWD:t}"
		local cwd_abs="${PWD:A}"
		local have_base=0 have_abs=0
		for k in "${pairs[@]}"; do
			[[ "$k" == "${cwd_base}="* ]] && have_base=1
			[[ "$k" == "${cwd_abs}="* ]] && have_abs=1
		done
		((have_base)) || pairs+=("${cwd_base}=${seza_theme_color}")
		((have_abs)) || pairs+=("${cwd_abs}=${seza_theme_color}")
	fi

	local eza_colors="${EZA_COLORS:-}"
	if (( ${#pairs[@]} )); then
		local joined_pairs
		local IFS=:
		joined_pairs="${pairs[*]}"
		if [[ -n "$eza_colors" ]]; then
			eza_colors="${eza_colors}:${joined_pairs}"
		else
			eza_colors="$joined_pairs"
		fi
	fi

	local -a argv
	argv=("$@")

	local want_icons=0
	local arg
	for arg in "${argv[@]}"; do
		[[ "$arg" == "--special-icons" ]] && want_icons=1
	done
	if (( want_icons )); then
		local -a filtered_args=()
		for arg in "${argv[@]}"; do
			[[ "$arg" == "--special-icons" ]] && continue
			filtered_args+=("$arg")
		done
		argv=("${filtered_args[@]}")
	fi

	if (( want_icons )); then
		local icons_kv="${EZA_SPECIAL_ICONS_KV:-}"
		if [[ -z "$icons_kv" ]] && typeset -p EZA_SPECIAL_ICONS >/dev/null 2>&1 && [[ "$(typeset -p EZA_SPECIAL_ICONS 2>/dev/null)" == *"-A"* ]]; then
			local -a icon_kv_flat=()
			eval 'icon_kv_flat=("${(@kv)EZA_SPECIAL_ICONS}")'
			local -a icon_pairs
			local i
			for ((i = 1; i <= ${#icon_kv_flat[@]}; i += 2)); do
				k="${icon_kv_flat[i]}"
				v="${icon_kv_flat[i + 1]}"
				icon_pairs+=("${k}=${v}")
			done
			if (( ${#icon_pairs[@]} )); then
				icons_kv="$(printf '%s\n' "${icon_pairs[@]}")"
			fi
		fi

		if [[ -n "$seza_theme_icon" ]]; then
			local cwd_base="${PWD:t}"
			local cwd_abs="${PWD:A}"
			local -a icon_lines
			if [[ -n "$icons_kv" ]]; then
				while IFS= read -r line; do
					icon_lines+=("$line")
				done <<<"$icons_kv"
			fi
			local have_base=0 have_abs=0
			for k in "${icon_lines[@]}"; do
				[[ "$k" == "${cwd_base}="* ]] && have_base=1
				[[ "$k" == "${cwd_abs}="* ]] && have_abs=1
			done
			((have_base)) || icon_lines+=("${cwd_base}=${seza_theme_icon}")
			((have_abs)) || icon_lines+=("${cwd_abs}=${seza_theme_icon}")
			if (( ${#icon_lines[@]} )); then
				icons_kv="$(printf '%s\n' "${icon_lines[@]}")"
			fi
		fi

		local -a env_prefix
		[[ -n "$eza_colors" ]] && env_prefix+=("EZA_COLORS=$eza_colors")
		[[ -n "$icons_kv" ]] && env_prefix+=("EZA_SPECIAL_ICONS_KV=$icons_kv")

		{ "${env_prefix[@]}" eza --oneline --icons --color=always "${argv[@]}"; } | python3 - <<'PY'
import fnmatch
import os
import re
import sys

ansi = re.compile(r'\x1b\[[0-9;]*m')
raw_map = os.environ.get("EZA_SPECIAL_ICONS_KV", "")
icons = {}
for line in raw_map.splitlines():
    if "=" in line:
        key, val = line.split("=", 1)
        icons[key] = val

for raw_line in sys.stdin:
    raw_line = raw_line.rstrip("\n")
    plain = ansi.sub("", raw_line).strip()
    if not plain:
        sys.stdout.write(raw_line + "\n")
        continue

    parts = plain.split(None, 1)
    name = parts[1] if len(parts) > 1 else parts[0]

    prefix = ""
    for pattern, icon in icons.items():
        if fnmatch.fnmatch(name, pattern):
            prefix = icon + " "
            break

    sys.stdout.write(prefix + raw_line + "\n")
PY
		return $?
	fi

	if [[ -n "$eza_colors" ]]; then
		EZA_COLORS="$eza_colors" eza --icons "${argv[@]}"
	else
		eza --icons "${argv[@]}"
	fi
}

export NAMESPACE="${NAMESPACE:-${SESSION_NAME:-$(basename "$PWD")}}"
apply_theme_vars "${COLOR_VAR:-$(rHex)}"
load_themefile
add-zsh-hook chpwd autoThemeFile
autoThemeFile
