#!/bin/zsh
#shellcheck disable=all

autoload -Uz add-zsh-hook

# Prevent double-loading.
[[ -n "${ZSH_THEMEFILE_LOADED:-}" ]] && return
ZSH_THEMEFILE_LOADED=1

# Clear any aliases that would cause "defining function based on alias 'theme'" warnings.
unalias theme 2>/dev/null

# Pick readable text against THEME_COLOR: black on light, white on dark.
apply_theme_vars() {
    local c="$1"

    export THEME_COLOR="$c"
    export COLOR_VAR="$THEME_COLOR"
    export FG_VAR="%F{$THEME_COLOR}"
    export BG_VAR="%K{$THEME_COLOR}"

    local hex="${c#\#}"
    if [[ ${#hex} -eq 3 ]]; then
        hex="${hex[1,1]}${hex[1,1]}${hex[2,1]}${hex[2,1]}${hex[3,1]}${hex[3,1]}"
    fi

    local r=$(( 16#${hex:0:2} ))
    local g=$(( 16#${hex:2:2} ))
    local b=$(( 16#${hex:4:2} ))
    local brightness=$(( (r * 299 + g * 587 + b * 114) / 1000 ))
    local threshold=$(( 0x88 ))
    if (( brightness > threshold )); then
        export FG_THEME_TEXT="%F{#000000}"
    else
        export FG_THEME_TEXT="%F{#FFFFFF}"
    fi

    export PS1="$PS1"
}


THEMEFILE() {
	local dir="${1:-$PWD}"
	echo "$(realpath "$dir")/.themefile"
}
alias theme-file=THEMEFILE

rHex() {
    local r g b
    r=$((RANDOM % 156 + 50))
    g=$((RANDOM % 156 + 50))
    b=$((RANDOM % 156 + 50))
    printf '#%02X%02X%02X\n' $r $g $b
}

is_hex() {
    local c="${1#\#}"
    [[ -n "$c" && "$c" =~ '^([[:xdigit:]]{3}|[[:xdigit:]]{6})$' ]]
}

normalize_hex() {
    local c="${1#\#}"
    if [[ ${#c} -eq 3 ]]; then
	c="${c[1]}${c[1]}${c[2]}${c[2]}${c[3]}${c[3]}"
    fi
    echo "#${c:u}"
}

PROMPT_COLOR() {
    local input="$1"
    while true; do
	[[ -z "$input" ]] && {
	    echo -n "Insert Hex (#RRGGBB): "
	    read -r input
	}
	is_hex "$input" || {
	    echo $'%F{yellow}Invalid hex color.%f'
	    input=""
	    continue
	}
	apply_theme_vars "$(normalize_hex "$input")"
	return 0
    done
}
alias PC=PROMPT_COLOR

NAMESPACE() { export NAMESPACE="$*"; }
alias NS=NAMESPACE
alias namespace=NAMESPACE

save_themefile() {
	local file="$(THEMEFILE)"
	local -a extras

	if [[ -f "$file" ]]; then
		local line
		while IFS= read -r line; do
			[[ "$line" == THEME_COLOR=* || "$line" == NAMESPACE=* || -z "$line" ]] && continue
			extras+=("$line")
		done <"$file"
	fi

	{
		echo "THEME_COLOR=\"$THEME_COLOR\""
		echo "NAMESPACE=\"$NAMESPACE\""
		((${#extras[@]})) && printf '%s\n' "${extras[@]}"
	} >|"$file"
}

load_themefile() {
	local file="$(THEMEFILE)"
	[[ -f "$file" ]] || return 0
	while IFS='=' read -r k v; do
		# Strip optional surrounding quotes for safer parsing.
		v="${v%\"}"
		v="${v#\"}"
		case "$k" in
		THEME_COLOR) apply_theme_vars "$v" ;;
		NAMESPACE) export NAMESPACE="$v" ;;
		esac
	done <"$file"
}

THEME() {
	case "$1" in
		set)
			shift
			SET_THEME "$@"
			return $?
			;;
		roll|random)
			shift
			THEME_ROLL "$@"
			return $?
			;;
		init)
			shift
			THEME_INIT "$@"
			return $?
			;;
		edit)
			shift
			THEMEEDIT "$@"
			return $?
			;;
	esac

	PROMPT_COLOR "$1" || return 1
	shift
	NAMESPACE "$*"
	save_themefile
	echo $'%F{yellow}Use at your own risk.%f'
}
theme() { THEME "$@"; }
alias theme=THEME
alias theme-init=THEME_INIT

THEME_ROLL() {
	emulate -L zsh

	local current=""
	[[ -n "${THEME_COLOR:-${COLOR_VAR:-}}" ]] && current="$(normalize_hex "${THEME_COLOR:-$COLOR_VAR}")"

    local new=""
    local attempts=0
    local max_attempts=12
    while (( attempts < max_attempts )); do
	new="$(rHex)"
	[[ -z "$current" ]] && break
	[[ "$(normalize_hex "$new")" != "$current" ]] && break
	((attempts++))
    done

    if [[ -n "$current" && "$(normalize_hex "$new")" == "$current" ]]; then
	local flipped=$(( (0x${current#\#} ^ 0x202020) & 0xFFFFFF ))
	new=$(printf '#%06X\n' "$flipped")
    fi

	apply_theme_vars "$new"
	save_themefile
	print -P $'%F{green}Applied random theme and saved to .themefile.%f'
}
theme_roll() { THEME_ROLL "$@"; }
alias theme-roll=THEME_ROLL

SET_THEME() {
	# Modes:
	#   set-theme [file]         -> load from file if it exists
	#   set-theme [color] [ns]   -> set to provided color/namespace
	#   set-theme                -> use current THEME_COLOR and default namespace (prompt)

	local arg1="${1:-}"
	local arg2="${2:-}"

	# Path load mode.
	if [[ -n "$arg1" && -f "$arg1" ]]; then
		local file="$arg1"
		local dir="$(dirname "$file")"
		NAMESPACE "${dir:t}"
		while IFS='=' read -r k v; do
			v="${v%\"}"
			v="${v#\"}"
			case "$k" in
			THEME_COLOR) apply_theme_vars "$v" ;;
			NAMESPACE) NAMESPACE "$v" ;;
			esac
		done <"$file"
		save_themefile
		echo $'%F{green}Loaded theme from%f' "$file"
		return 0
	fi

	# Color/ns mode.
	local color ns
	color="${arg1:-${THEME_COLOR:-${COLOR_VAR:-}}}"
	ns="${arg2:-${NAMESPACE:-$(print -P %2~)}}"

	# Confirm when values were taken from defaults (i.e., no explicit args).
	if [[ -z "$arg1" && -z "$arg2" ]]; then
		printf 'Use color %s and namespace "%s"? (y/N) ' "$color" "$ns" >&2
		if ! read -q reply; then
			echo
			echo "Aborted."
			return 1
		fi
		echo
	fi

	if ! is_hex "$color"; then
		echo $'%F{red}Invalid color. Use #RRGGBB.%f'
		return 1
	fi

	apply_theme_vars "$(normalize_hex "$color")"
	NAMESPACE "$ns"
	save_themefile
	echo $'%F{green}Saved theme to .themefile.%f'
}
set_theme() { SET_THEME "$@"; }
alias set-theme=SET_THEME

THEME_INIT() {
	local color ns
	color="${1:-${THEME_COLOR:-$COLOR_VAR}}"
	ns="${2:-$NAMESPACE}"
    echo "
Received:

argv : Array($#)
"
    local counter=0
    while IFS= read -r line; do
	echo "argv[$counter]: $line"
	local counter=$((counter + 1))
    done <<<"$(print \"$@\")"
    

    if [[ -z "${1:-}" ]]; then
	print -n -- "Theme color [${color}]: "
	IFS= read -r reply_color
	[[ -n "$reply_color" ]] && color="$reply_color"
    fi
    if [[ -z "${2:-}" ]]; then
	print -n -- "Namespace [${ns}]: "
	IFS= read -r reply_ns
	[[ -n "$reply_ns" ]] && ns="$reply_ns"
    fi

    is_hex "$color" || {
	echo "is_hex returned.. \"$(is_hex "$color")\""

	echo $'%F{red}Invalid color. Use #RRGGBB.%f'
	return 1
    }

	apply_theme_vars "$(normalize_hex "$color")"
	NAMESPACE "$ns"
	save_themefile
	echo $'%F{green}Wrote theme to .themefile in this directory.%f'
}
theme_init() { THEME_INIT "$@"; }

THEMEEDIT() {
	local f="$(THEMEFILE)"
	touch "$f"
	${EDITOR:-vi} "$f"
	load_themefile
}
theme_edit() { THEMEEDIT "$@"; }
alias theme-edit=THEMEEDIT

autoThemeFile() {
    (( $+functions[load_themefile] )) || return 0
    load_themefile
}

seza() {
    emulate -L zsh
    setopt pipefail

    local themefile
    if (( $+functions[THEMEFILE] )); then
	themefile="$(THEMEFILE)"
    else
	themefile="${THEMEFILE:-$HOME/.themefile}"
    fi
    [[ -f "$themefile" ]] && source "$themefile"

    local seza_theme_color="${THEME_COLOR:-${COLOR_VAR:-}}"
    local THEME_COLOR_ICON=""
    if [[ -n "${SEZA_ICON:-}" ]]; then
	THEME_COLOR_ICON="$SEZA_ICON"
    elif [[ -n "${SEZA_NAMESPACE_ICON:-}" ]]; then
	THEME_COLOR_ICON="$SEZA_NAMESPACE_ICON"
    elif [[ -n "${NAMESPACE:-}" ]]; then
	THEME_COLOR_ICON="$NAMESPACE"
    fi

    if ! command -v eza >/dev/null 2>&1; then
	print -u2 "seza: eza is not installed"
	return 127
    fi

    local -a pairs
    local k v
    if typeset -p EZA_SPECIAL >/dev/null 2>&1; then
	if [[ "$(typeset -p EZA_SPECIAL 2>/dev/null)" == *"-A"* ]]; then
	    typeset -A EZA_SPECIAL
	    local -a __eza_special_keys=()
	    eval '__eza_special_keys=("${(@k)EZA_SPECIAL}")'
	    for k in "${__eza_special_keys[@]}"; do
		v="${EZA_SPECIAL[$k]}"
		pairs+=("${k}=${v}")
	    done
	else
	    for k in "${EZA_SPECIAL[@]}"; do
		pairs+=("$k")
	    done
	fi
    fi

    if [[ -n "$seza_theme_color" ]]; then
	local cwd_base="${PWD:t}"
	local cwd_abs="${PWD:A}"
	local have_base=0 have_abs=0
	for k in "${pairs[@]}"; do
	    [[ "$k" == "${cwd_base}="* ]] && have_base=1
	    [[ "$k" == "${cwd_abs}="* ]] && have_abs=1
	done
	((have_base)) || pairs+=("${cwd_base}=${seza_theme_color}")
	((have_abs)) || pairs+=("${cwd_abs}=${seza_theme_color}")
    fi

    local eza_colors="${EZA_COLORS:-}"
    if (( ${#pairs[@]} )); then
	local joined_pairs
	local IFS=:
	joined_pairs="${pairs[*]}"
	if [[ -n "$eza_colors" ]]; then
	    eza_colors="${eza_colors}:${joined_pairs}"
	else
	    eza_colors="$joined_pairs"
	fi
    fi

    local -a argv
    argv=("$@")

    local want_icons=0
    local arg
    for arg in "${argv[@]}"; do
	[[ "$arg" == "--special-icons" ]] && want_icons=1
    done
    if (( want_icons )); then
	local -a filtered_args=()
	for arg in "${argv[@]}"; do
	    [[ "$arg" == "--special-icons" ]] && continue
	    filtered_args+=("$arg")
	done
	argv=("${filtered_args[@]}")
    fi

    if (( want_icons )); then
	local icons_kv="${EZA_SPECIAL_ICONS_KV:-}"
	if [[ -z "$icons_kv" ]] && typeset -p EZA_SPECIAL_ICONS >/dev/null 2>&1 && [[ "$(typeset -p EZA_SPECIAL_ICONS 2>/dev/null)" == *"-A"* ]]; then
	    local -a icon_kv_flat=()
	    eval 'icon_kv_flat=("${(@kv)EZA_SPECIAL_ICONS}")'
	    local -a icon_pairs
	    local i
	    for ((i = 1; i <= ${#icon_kv_flat[@]}; i += 2)); do
		k="${icon_kv_flat[i]}"
		v="${icon_kv_flat[i + 1]}"
		icon_pairs+=("${k}=${v}")
	    done
	    if (( ${#icon_pairs[@]} )); then
		icons_kv="$(printf '%s\n' "${icon_pairs[@]}")"
	    fi
	fi

	if [[ -n "$THEME_COLOR_ICON" ]]; then
	    local cwd_base="${PWD:t}"
	    local cwd_abs="${PWD:A}"
	    local -a icon_lines
	    if [[ -n "$icons_kv" ]]; then
		while IFS= read -r line; do
		    icon_lines+=("$line")
		done <<<"$icons_kv"
	    fi
	    local have_base=0 have_abs=0
	    for k in "${icon_lines[@]}"; do
		[[ "$k" == "${cwd_base}="* ]] && have_base=1
		[[ "$k" == "${cwd_abs}="* ]] && have_abs=1
	    done
	    ((have_base)) || icon_lines+=("${cwd_base}=${THEME_COLOR_ICON}")
	    ((have_abs)) || icon_lines+=("${cwd_abs}=${THEME_COLOR_ICON}")
	    if (( ${#icon_lines[@]} )); then
		icons_kv="$(printf '%s\n' "${icon_lines[@]}")"
	    fi
	fi

	local -a env_prefix
	[[ -n "$eza_colors" ]] && env_prefix+=("EZA_COLORS=$eza_colors")
	[[ -n "$icons_kv" ]] && env_prefix+=("EZA_SPECIAL_ICONS_KV=$icons_kv")

	{ "${env_prefix[@]}" eza --oneline --icons --color=always "${argv[@]}"; } | python3 - <<'PY'
import fnmatch
import os
import re
import sys

ansi = re.compile(r'\x1b\[[0-9;]*m')
raw_map = os.environ.get("EZA_SPECIAL_ICONS_KV", "")
icons = {}
for line in raw_map.splitlines():
    if "=" in line:
        key, val = line.split("=", 1)
        icons[key] = val

for raw_line in sys.stdin:
    raw_line = raw_line.rstrip("\n")
    plain = ansi.sub("", raw_line).strip()
    if not plain:
        sys.stdout.write(raw_line + "\n")
        continue

    parts = plain.split(None, 1)
    name = parts[1] if len(parts) > 1 else parts[0]

    prefix = ""
    for pattern, icon in icons.items():
        if fnmatch.fnmatch(name, pattern):
            prefix = icon + " "
            break

    sys.stdout.write(prefix + raw_line + "\n")
PY
	return $?
    fi

    if [[ -n "$eza_colors" ]]; then
	EZA_COLORS="$eza_colors" eza --icons "${argv[@]}"
    else
	eza --icons "${argv[@]}"
    fi
}

export NAMESPACE="${NAMESPACE:-${SESSION_NAME:-$(basename "$PWD")}}"
apply_theme_vars "${THEME_COLOR:-${COLOR_VAR:-$(rHex)}}"
load_themefile
add-zsh-hook chpwd autoThemeFile
autoThemeFile
