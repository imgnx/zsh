#!/bin/zsh
prompt_hook() {
	echo -en "${ACTIVE_VENV_MSG:-\033[38;2;0;255;0m  Python\033[0m .venv: [${AUTOVENV_DIR}/${AUTOVENV_BASE}] (v${version:-unknown})}"
}

wrap_deactivate() {
	add-zsh-hook -d precmd prompt_hook
}

activate_venv() {
	if [[ $PY_DEBUG == 1 ]]; then
		echo -e "\`venv_autoactivate\`: Attempting to activate [venv]:
\$REALPATH: $1
\$ACTFILE: $2
"
		ls -la $ACTFILE

		echo "\`venv_autoactivate\`: PS1 has venv: $PS1_HAS_VENV"
	fi

	local REALPATH="$1"
	local ACTFILE="$2"

	export AUTOVENV_DIR="$(basename "$(dirname "$REALPATH")")"
	local AUTOVENV_BASE="$(basename "$REALPATH")"
	local version=""
	local venv_python=""
	local VENV_BIN=""
	local VENV_ROOT=""
	if [[ $PS1_HAS_VENV == 1 ]]; then
		echo "Cannot activate [${AUTOVENV_DIR}/${AUTOVENV_BASE}]. A .venv is already active ($PS1_HAS_VENV) for $ACTIVE_VENV_MSG"
		return 1
	fi

	# Keep Python's activate script from touching the prompt; use our precmd hook instead.
	export VIRTUAL_ENV_DISABLE_PROMPT=1
	source "$ACTFILE"

	VENV_BIN="$(dirname "$ACTFILE")"
	VENV_ROOT="$(dirname "$VENV_BIN")"

	# Ensure PATH and VIRTUAL_ENV point at the venv even if activate didn't touch them.
	if [[ -z "$VIRTUAL_ENV" ]]; then
		export VIRTUAL_ENV="$VENV_ROOT"
	fi
	if [[ "${path[1]}" != "$VENV_BIN" ]]; then
		typeset -U path
		path=($VENV_BIN $path)
	fi
	hash -r 2>/dev/null

	# Prefer the venv's interpreter so we don't accidentally hit a global Homebrew Python.
	if [[ -n "$VIRTUAL_ENV" && -x "$VIRTUAL_ENV/bin/python" ]]; then
		venv_python="$VIRTUAL_ENV/bin/python"
	elif [[ -x "$VENV_BIN/python" ]]; then
		venv_python="$VENV_BIN/python"
	elif [[ -x "$VENV_BIN/python3" ]]; then
		venv_python="$VENV_BIN/python3"
	fi
	
	if [[ -n "$venv_python" ]]; then
		version="$("$venv_python" -V 2>/dev/null | /opt/homebrew/bin/awk '{print $2}')"
	else
		version="$(command python -V 2>/dev/null | /opt/homebrew/bin/awk '{print $2}')"
	fi
	# export PS1L1="$(print -P $PS1 | head -n 1)"
	# export PS1L2="$(print -P $PS1 | tail -n +2)"
	# export PS1='$PS1L1 $ACTIVE_VENV_MSG
	# $PS1L2'
	# export PS1_HAS_VENV=1
	export ACTIVE_VENV_MSG="\033[38;2;0;255;0m  Python\033[0m .venv: [${AUTOVENV_DIR}/${AUTOVENV_BASE}] (v${version:-unknown})"
	add-zsh-hook precmd prompt_hook
}

venv_autoactivate() {
	add-zsh-hook -d precmd venv_autoactivate
	if [[ $PY_DEBUG == 1 ]]; then
		echo "exec: venv_autoactivate in $ZDOTDIR/fn.sh"
	fi
	VENVAUTO_FILE="$ZDOTDIR/.zsh_venv_auto"
	PS1_HAS_VENV="${PS1_HAS_VENV:-0}"
	export VIRTUAL_ENV_DISABLE_PROMPT=1
	local errno=1 # pessimistic default
	local net=1   # safety net: allows retry once
	local ACTFILE dir decision reply

	TRAPEXIT() {
		unset VIRVUAL_ENV
		unset PS1_HAS_VENV
		# If we failed AND net is still armed, retry exactly once
		if ((errno != 0 && net == 1)); then
			net=0
			echo -e "\033[1m\033[38;2;255;125;0mWait!\033[0m"
			venv_autoactivate
		fi
	}

	# Bail immediately in $HOME
	if [[ "$(realpath "$PWD")" == "$(realpath "$HOME")" ]]; then
		errno=0
		return
	fi

	# Already in a venv → nothing to do
	if [[ -n "$VIRTUAL_ENV" ]]; then
		deactivate &>/dev/null # Simple. They get it wrong, we destroy it.
		# or ...
		# deactivate >/dev/null 2>&1
	fi

	if [[ "$PY_DEBUG" == 1 ]]; then
		echo "Searching for activation file..."
	fi

	# Locate activation script
	# `-mindepth 3 maxdepth 3` should lock it down to the exact place where .venv is located.
	ACTFILE=$(find . -maxdepth 3 -mindepth 3 -type f -name activate 2>/dev/null | head -n 1)

	# Fallback: walk upward a few levels for a shared project .venv.
	if [[ -z "$ACTFILE" ]]; then
		local updir="$PWD"
		for _ in {1..4}; do
			if [[ -f "$updir/.venv/bin/activate" ]]; then
				ACTFILE="$updir/.venv/bin/activate"
				break
			fi
			[[ "$updir" == "/" ]] && break
			updir="$(dirname "$updir")"
		done
	fi

	if [[ "$PY_DEBUG" == 1 ]]; then
		echo "Results: $ACTFILE"
	fi

	if [[ -z "$ACTFILE" ]]; then
		errno=0
		return
	fi

	dir=$(realpath "$(dirname "$ACTFILE")")
	REALPATH="$(realpath ./)"

	# Check remembered decisions
	record=$(grep "^$dir " "$VENVAUTO_FILE" 2>/dev/null)
	decision=$(echo $record | awk '{print $2}')

	case "$decision" in
	always)
		# echo "Python .venv activated\!" | lolcat -paf
		activate_venv $REALPATH $ACTFILE
		errno=0
		return
		;;
	never)
		echo "\033[41m autovenv disabled: \033[0m ${record}"
		errno=0
		return
		;;
	esac

	# Prompt user
	echo -en "\033[5m\033[48;2;0;123;255mActivate .venv in $dir?\033[0m \033[1m
	1. (y)es
	2. (n)o
	3. (a)lways
	4. (N)ever\033[0m

Decision:"
	read -k 1 -r reply
	echo

	case "$reply" in
	[yY1])
		echo -e "$ACTFILE set to \033[48;2;0;255;0mactivate once\033[0m"
		activate_venv $REALPATH $ACTFILE
		;;
	[aA3])
		echo -e "$ACTFILE set to \033[48;2;0;255;0malways\033[0m"
		activate_venv $REALPATH $ACTFILE
		echo "$dir always" | tee "$VENVAUTO_FILE"
		;;
	[N4])
		echo -e "$ACTFILE set to \033[48;2;255;20;0mnever\033[0m"
		echo "$dir never" | tee "$VENVAUTO_FILE"
		;;
	*) ;; # explicit no-op
	esac

	errno=0
}

venvreset() {
	if [[ "$1" == "edit" ]]; then
		${EDITOR:-emacs} "$VENVAUTO_FILE"
	else
		rm$() -f "$VENVAUTO_FILE"
		echo "Cleared all venv auto-activation decisions."
	fi
}

add-zsh-hook precmd venv_autoactivate
add-zsh-hook chpwd venv_autoactivate
